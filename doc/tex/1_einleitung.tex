% Mit \section{...} eröffnen wir einen neuen Abschnitt.
% Der Befehl setzt nicht nur den Text in einer größeren,
% fetten Schrift, sondern sorgt außerdem dafür, daß er im
% Inhaltsverzeichnis erscheint.
%
% Mit \label{...} erzeugen wir einen Bezeichner, mit dessen Hilfe
% wir später auf die Nummer des Abschnitts verweisen können (nämlich
% mit~\ref{...}).
%
% Das Kommentarzeichen hinter „Übersicht“ dient dazu, ein
% Leerzeichen zwischen „Übersicht“ und dem \label-Befehl
% zu vermeiden, das andernfalls sichtbar würde – z.B. im
% Inhaltsverzeichnis.
%

% % Imports nur für Referenzenauflösung während des Schreibens! Vorm Kompilieren auskommentieren!
% \bibliography{0_hauptdatei}
% \input{1_einleitung}
%\input{2_grundlagen}
%\input{3_konzeption}
%\input{4_implementierung}
%\input{5_tests}
%\input{6_zusammenfassung}
% % Ende Imports

\section{Einleitung und Motivation%
  \label{sec:1-einleitung}}
Ziel dieses Projektes ist die Integration eines OPC-Servers mit einer auf Linux
basierenden speicherprogrammierbaren Steuerung (SPS). Der OPC-Server implementiert das
in der Automatisierungstechnik etablierte, IP-basierte und in einem offenen Standard 
definierte Protokoll OPC-UA.
Angeschlossen an die SPS ist jeweils ein digitales Ein-/\,bzw.~Ausgabemodul. 
Die von diesen Modulen bereitgestellten Ein-/\, bzw.~Ausgänge (IO) sollen in 
der Datenstruktur des OPC-Servers abgebildet werden.

Weiterhin sollen einige Funktionen zur Überwachung und Steuerung der an die SPS 
angeschlossenen Aktoren und Sensoren direkt serverseitig implementiert und potentiellen Clients per Applikationsschnittstelle bzw. Application Programming Interface (API) zur Verfügung gestellt werden.
Hiermit stellt dieses Projekt eine der Grundlagen für ein übergeordnetes Projekt,
die cloudbasierte Steuerung eines miniaturisierten Produktionssystems, dar.

Das Hauptaugenmerk liegt in dieser Arbeit auf der Anbindung der physischen Ein- und Ausgänge der SPS an den OPC-Server.
Diese erfolgt mittels eines Kernel-Moduls und ioctl-Aufrufen. Die Verwendung eines echtzeitfähigen Linux-Kernels soll
Echtzeit im Sinne garantierter Zykluszeiten für das Lesen und Schreiben von Ein- bzw. Ausgängen gewährleisten.

Der hier verwendete OPC-Server ist Teil des sog. open62541 Projektes. Er ist in C
geschrieben und implementiert bereits einen großen Teil der im OPC-UA-Standard
spezifizierten Funktionen.
Als SPS findet ein Revolution Pi 3 der Firma Kunbus Verwendung. Dieser integriert
ein sog. Compute Module der Raspberry Pi Foundation in ein zur industriellen 
Verwendung geeignetes Gehäuse und erlaubt die Erweiterung mittels IO- oder Gateway-Modulen. 
Diese ermöglichen die Anbindung an weitere Komponenten der Automatisierungstechnik.

Motiviert ist dieses Projekt durch die Beobachtung, dass die Verbreitung offener
Standards sowie freier Software auch in der Automatisierungstechnik zunimmt.
Linux ist ein freies Betriebssystem, OPC-UA ein offen zugänglicher, aktiv gepflegter
und weit verbreiteter Standard. Der Raspberry Pi findet sowohl bei Hobby-Anwendern als
auch in den Bereichen Forschung und Entwicklung sowie bei industriellen Anwendern
Verwendung. Dieses Projekt stellt somit eine für unterschiedliche Anwender interessante
Entwicklung dar.

Im Anschluss an diese einleitende Übersicht im Abschnitt~\ref{sec:1-einleitung} folgt
die Darstellung der wichtigsten Grundlagen in Abschnitt~\ref{sec:2-grundlagen}.
Aufbauend auf diesen Grundlagen folgt die konzeptuelle Ausarbeitung im Abschnitt~\ref{sec:3-konzeption}.
Die Umsetzung wird im Abschnitt~\ref{sec:4-implementierung} erläutert.
Die Leistungsfähigkeit der Implementierung wird in Abschnitt~\ref{sec:5-tests} untersucht.
Eine Zusammenfassung und ein Ausblick schließen die Arbeit in
Abschnitt~\ref{sec:6-fazit} ab.

Der vollständige Quellcode sowie ergänzende Dokumentation ist auf Github im Projektverzeichnis serverless\_plc des Nutzers CVH-Lernfabrik verfügbar\footnote{siehe \url{ https://github.com/CVH-Lernfabrik/serverless_plc}}.